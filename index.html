<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Test Plan Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* Enhanced Markdown Styling */
        #output {
            line-height: 1.8;
            color: #334155;
        }
        
        #output h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #1e293b;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #6366f1;
        }
        
        #output h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #334155;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.25rem;
            border-bottom: 2px solid #cbd5e1;
        }
        
        #output h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #475569;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }
        
        #output p {
            margin-bottom: 1rem;
        }
        
        #output ul, #output ol {
            margin-bottom: 1rem;
            padding-left: 1.5rem;
        }
        
        #output li {
            margin-bottom: 0.5rem;
        }
        
        /* Table wrapper for horizontal scrolling */
        #output .table-wrapper {
            overflow-x: auto;
            margin: 1.5rem 0;
            -webkit-overflow-scrolling: touch;
        }
        
        #output table {
            width: 100%;
            min-width: 600px;
            border-collapse: collapse;
            margin: 0;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            background: white;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid #cbd5e1;
            display: table !important;
            table-layout: auto;
        }
        
        #output thead {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
        }
        
        #output th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        #output td {
            padding: 0.875rem 1rem;
            border-bottom: 1px solid #e2e8f0;
        }
        
        #output tbody tr {
            transition: background-color 0.2s;
        }
        
        #output tbody tr:hover {
            background-color: #f8fafc;
        }
        
        #output tbody tr:last-child td {
            border-bottom: none;
        }
        
        #output tbody tr:nth-child(even) {
            background-color: #f8fafc;
        }
        
        /* Ensure tables are always visible */
        #output table,
        #output table * {
            visibility: visible !important;
            display: table !important;
        }
        
        #output thead {
            display: table-header-group !important;
        }
        
        #output tbody {
            display: table-row-group !important;
        }
        
        #output tr {
            display: table-row !important;
        }
        
        #output th,
        #output td {
            display: table-cell !important;
        }
        
        #output code {
            background-color: #f1f5f9;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.875em;
            color: #e11d48;
        }
        
        #output pre {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1rem 0;
        }
        
        #output pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
        }
        
        #output blockquote {
            border-left: 4px solid #6366f1;
            padding-left: 1rem;
            margin: 1rem 0;
            color: #64748b;
            font-style: italic;
        }
        
        #output strong {
            color: #1e293b;
            font-weight: 600;
        }
        
        #output hr {
            border: none;
            border-top: 2px solid #e2e8f0;
            margin: 2rem 0;
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- Header -->
        <div class="mb-8">
            <h1 class="text-4xl font-bold text-slate-900 mb-2">AI Test Plan Generator</h1>
            <p class="text-slate-600">Generate comprehensive test plans powered by AI</p>
        </div>

        <!-- API Key Input -->
        <div class="bg-white rounded-lg shadow-sm border border-slate-200 p-6 mb-6">
            <label for="apiProvider" class="block text-sm font-medium text-slate-700 mb-2">
                AI Provider
            </label>
            <div class="mb-4">
                <select 
                    id="apiProvider" 
                    class="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none"
                >
                    <option value="openai">OpenAI (GPT-4)</option>
                    <option value="gemini">Google Gemini</option>
                </select>
            </div>
            <label for="apiKey" class="block text-sm font-medium text-slate-700 mb-2">
                API Key
            </label>
            <div class="flex gap-2">
                <div class="flex-1">
                    <input 
                        type="password" 
                        id="apiKey" 
                        placeholder="Enter your API key..." 
                        class="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none"
                    />
                    <p id="apiKeyValidation" class="text-xs mt-1 hidden"></p>
                </div>
                <button 
                    id="saveApiKey" 
                    class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-medium"
                >
                    Save Key
                </button>
            </div>
            <p class="text-xs text-slate-500 mt-2">Your API key is stored locally in your browser session</p>
        </div>

        <!-- Token Limit Slider -->
        <div class="bg-white rounded-lg shadow-sm border border-slate-200 p-6 mb-6">
            <label for="tokenLimit" class="block text-sm font-medium text-slate-700 mb-2">
                Response Token Limit: <span id="tokenLimitValue" class="text-indigo-600 font-semibold">16000</span>
            </label>
            <div class="space-y-2">
                <input 
                    type="range" 
                    id="tokenLimit" 
                    min="16000" 
                    max="32000" 
                    step="1000" 
                    value="16000"
                    class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
                />
                <div class="flex justify-between text-xs text-slate-500">
                    <span>16K (Minimum)</span>
                    <span id="tokenLimitMax">32K (Maximum)</span>
                </div>
            </div>
            <p class="text-xs text-slate-500 mt-2">
                Higher limits allow for more detailed responses but may increase API costs and response time.
                <span id="tokenLimitNote" class="text-indigo-600 font-medium"></span>
            </p>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Input Section (Left Sidebar) -->
            <div class="lg:col-span-1 space-y-6">
                <!-- File Upload -->
                <div class="bg-white rounded-lg shadow-sm border border-slate-200 p-6">
                    <h2 class="text-xl font-semibold text-slate-900 mb-4">Requirements Document</h2>
                    <div class="border-2 border-dashed border-slate-300 rounded-lg p-6 text-center hover:border-indigo-400 transition-colors">
                        <input 
                            type="file" 
                            id="fileInput" 
                            accept=".pdf,.txt" 
                            class="hidden"
                        />
                        <label for="fileInput" class="cursor-pointer">
                            <svg class="mx-auto h-12 w-12 text-slate-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                            </svg>
                            <p class="text-sm text-slate-600 mb-1">Click to upload or drag and drop</p>
                            <p class="text-xs text-slate-500">PDF or TXT files only</p>
                        </label>
                    </div>
                    <div id="fileName" class="mt-3 text-sm text-indigo-600 font-medium hidden"></div>
                </div>

                <!-- ETA Input -->
                <div class="bg-white rounded-lg shadow-sm border border-slate-200 p-6">
                    <label for="eta" class="block text-sm font-medium text-slate-700 mb-2">
                        Execution Timeline
                    </label>
                    <input 
                        type="text" 
                        id="eta" 
                        placeholder="e.g., 2 weeks, 1 month" 
                        class="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none"
                    />
                </div>

                <!-- Resource Manager -->
                <div class="bg-white rounded-lg shadow-sm border border-slate-200 p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-slate-900">Test Team</h2>
                        <button 
                            id="addTester" 
                            class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors text-sm font-medium"
                        >
                            + Add Tester
                        </button>
                    </div>
                    <div id="testersList" class="space-y-4">
                        <!-- Testers will be added here dynamically -->
                    </div>
                    <p id="noTesters" class="text-sm text-slate-500 text-center py-4">No testers added yet</p>
                </div>

                <!-- Generate Button -->
                <button 
                    id="generateBtn" 
                    class="w-full px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors font-semibold text-lg shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled
                >
                    Generate Test Plan
                </button>
            </div>

            <!-- Output Section (Right Side) -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-lg shadow-sm border border-slate-200 p-6 min-h-[600px]">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-slate-900">Generated Test Plan</h2>
                        <button 
                            id="downloadPdf" 
                            class="px-4 py-2 bg-slate-600 text-white rounded-lg hover:bg-slate-700 transition-colors text-sm font-medium hidden"
                        >
                            Download PDF
                        </button>
                    </div>
                    <div id="output" class="max-w-none overflow-auto">
                        <div class="text-center text-slate-400 py-20">
                            <svg class="mx-auto h-16 w-16 mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <p>Your generated test plan will appear here</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-8 max-w-md mx-4 text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p class="text-slate-700 font-medium">Generating your test plan...</p>
            <p class="text-sm text-slate-500 mt-2">This may take a few moments</p>
        </div>
    </div>

    <script>
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize PDF.js worker
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            } else {
                console.error('PDF.js library not loaded');
            }

            // Configure marked.js for table support (GFM mode)
            if (typeof marked !== 'undefined') {
                marked.setOptions({
                    gfm: true, // Enable GitHub Flavored Markdown (includes tables)
                    breaks: true, // Convert line breaks to <br>
                    headerIds: false,
                    mangle: false
                });
            }

            // State management
            let apiProvider = sessionStorage.getItem('ai_provider') || 'openai';
            let apiKey = sessionStorage.getItem(`${apiProvider}_api_key`) || '';
            let testers = [];
            let tokenLimit = parseInt(sessionStorage.getItem('token_limit')) || 16000;

            // Provider configurations
            const providers = {
                openai: {
                    name: 'OpenAI',
                    keyPrefix: 'sk-',
                    placeholder: 'sk-...',
                    keyUrl: 'https://platform.openai.com/account/api-keys',
                    validate: (key) => key.startsWith('sk-')
                },
                gemini: {
                    name: 'Google Gemini',
                    keyPrefix: 'AIza',
                    placeholder: 'AIza...',
                    keyUrl: 'https://makersuite.google.com/app/apikey',
                    validate: (key) => key.startsWith('AIza')
                }
            };

            // DOM Elements
            const apiProviderSelect = document.getElementById('apiProvider');
            const apiKeyInput = document.getElementById('apiKey');
            const apiKeyValidation = document.getElementById('apiKeyValidation');
            const saveApiKeyBtn = document.getElementById('saveApiKey');
            const tokenLimitSlider = document.getElementById('tokenLimit');
            const tokenLimitValue = document.getElementById('tokenLimitValue');
            const tokenLimitNote = document.getElementById('tokenLimitNote');
            const tokenLimitMax = document.getElementById('tokenLimitMax');
            const fileInput = document.getElementById('fileInput');
            const fileName = document.getElementById('fileName');
            const etaInput = document.getElementById('eta');
            const addTesterBtn = document.getElementById('addTester');
            const testersList = document.getElementById('testersList');
            const noTesters = document.getElementById('noTesters');
            const generateBtn = document.getElementById('generateBtn');
            const output = document.getElementById('output');
            const downloadPdfBtn = document.getElementById('downloadPdf');
            const loadingOverlay = document.getElementById('loadingOverlay');

            // Load saved provider and API key
            apiProviderSelect.value = apiProvider;
            if (apiKey) {
                apiKeyInput.value = apiKey;
            }
            updatePlaceholder();
            updateTokenLimitUI();

            // Update placeholder when provider changes
            apiProviderSelect.addEventListener('change', (e) => {
                apiProvider = e.target.value;
                sessionStorage.setItem('ai_provider', apiProvider);
                // Load provider-specific key
                apiKey = sessionStorage.getItem(`${apiProvider}_api_key`) || '';
                apiKeyInput.value = apiKey;
                updatePlaceholder();
                validateApiKey(apiKey);
                updateTokenLimitMax();
                checkGenerateButtonState();
            });

            // Token Limit Slider Handler
            function updateTokenLimitMax() {
                // OpenAI GPT-4 max is 16,384, but we'll allow up to 32K for future models
                // Gemini can handle up to 32K or more
                const maxLimit = apiProvider === 'openai' ? 16384 : 32000;
                tokenLimitSlider.max = maxLimit;
                tokenLimitMax.textContent = `${(maxLimit / 1000).toFixed(0)}K (Maximum)`;
                if (tokenLimit > maxLimit) {
                    tokenLimit = maxLimit;
                    tokenLimitSlider.value = tokenLimit;
                    sessionStorage.setItem('token_limit', tokenLimit);
                }
                updateTokenLimitUI();
            }

            function updateTokenLimitUI() {
                const value = parseInt(tokenLimitSlider.value);
                tokenLimit = value;
                tokenLimitValue.textContent = value.toLocaleString();
                
                // Update note based on value
                if (value >= 30000) {
                    tokenLimitNote.textContent = 'Very high limit - may result in longer response times.';
                } else if (value >= 20000) {
                    tokenLimitNote.textContent = 'High limit - good for comprehensive test plans.';
                } else {
                    tokenLimitNote.textContent = 'Standard limit - suitable for most test plans.';
                }
                
                // Save to sessionStorage
                sessionStorage.setItem('token_limit', tokenLimit);
            }

            // Initialize token limit slider
            tokenLimitSlider.value = tokenLimit;
            updateTokenLimitMax();
            
            // Update token limit when slider changes
            tokenLimitSlider.addEventListener('input', updateTokenLimitUI);

            function updatePlaceholder() {
                const provider = providers[apiProvider];
                apiKeyInput.placeholder = provider.placeholder;
            }

            function validateApiKey(key) {
                if (key.length === 0) {
                    apiKeyValidation.classList.add('hidden');
                    apiKeyInput.classList.remove('border-red-300', 'border-green-300');
                    apiKeyInput.classList.add('border-slate-300');
                    return false;
                }
                
                const provider = providers[apiProvider];
                apiKeyValidation.classList.remove('hidden');
                apiKeyInput.classList.remove('border-slate-300', 'border-red-300', 'border-green-300');
                
                if (provider.validate(key)) {
                    apiKeyValidation.textContent = `‚úÖ Valid ${provider.name} API key format`;
                    apiKeyValidation.className = 'text-xs mt-1 text-green-600';
                    apiKeyInput.classList.add('border-green-300');
                    return true;
                } else {
                    apiKeyValidation.textContent = `‚ö†Ô∏è Invalid format! ${provider.name} keys start with "${provider.keyPrefix}"`;
                    apiKeyValidation.className = 'text-xs mt-1 text-red-600';
                    apiKeyInput.classList.add('border-red-300');
                    return false;
                }
            }

            // Real-time API key validation
            apiKeyInput.addEventListener('input', (e) => {
                validateApiKey(e.target.value.trim());
            });

            // Save API Key
            saveApiKeyBtn.addEventListener('click', () => {
                apiKey = apiKeyInput.value.trim();
                if (!apiKey) {
                    alert('Please enter an API key');
                    return;
                }
                
                const provider = providers[apiProvider];
                
                // Validate API key format
                if (!provider.validate(apiKey)) {
                    alert(`‚ö†Ô∏è Invalid API key format!\n\n${provider.name} API keys should start with "${provider.keyPrefix}".\n\nYou entered a key starting with "${apiKey.substring(0, 7)}..."\n\nPlease get your ${provider.name} API key from: ${provider.keyUrl}`);
                    apiKeyInput.focus();
                    return;
                }
                
                sessionStorage.setItem(`${apiProvider}_api_key`, apiKey);
                sessionStorage.setItem('ai_provider', apiProvider);
                alert(`‚úÖ ${provider.name} API key saved successfully!`);
                checkGenerateButtonState();
            });

            // File Upload Handler
            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                fileName.textContent = `üìÑ ${file.name}`;
                fileName.classList.remove('hidden');
                checkGenerateButtonState();
            });

            // Extract text from file
            async function extractTextFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        if (file.type === 'application/pdf' || file.name.endsWith('.pdf')) {
                            // Extract text from PDF
                            const arrayBuffer = e.target.result;
                            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                            let fullText = '';

                            for (let i = 1; i <= pdf.numPages; i++) {
                                const page = await pdf.getPage(i);
                                const textContent = await page.getTextContent();
                                const pageText = textContent.items.map(item => item.str).join(' ');
                                fullText += pageText + '\n';
                            }

                            resolve(fullText);
                        } else if (file.type === 'text/plain' || file.name.endsWith('.txt')) {
                            // Extract text from TXT
                            resolve(e.target.result);
                        } else {
                            reject(new Error('Unsupported file type'));
                        }
                    } catch (error) {
                        reject(error);
                    }
                };

                reader.onerror = reject;
                
                if (file.type === 'application/pdf' || file.name.endsWith('.pdf')) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });
        }

            // Add Tester
            addTesterBtn.addEventListener('click', () => {
                const testerId = Date.now();
                testers.push({
                    id: testerId,
                    experience: 0,
                    specialization: 'Manual'
                });
                renderTesters();
                checkGenerateButtonState();
            });

            // Render Testers
            function renderTesters() {
            if (testers.length === 0) {
                noTesters.classList.remove('hidden');
                testersList.innerHTML = '';
                return;
            }

            noTesters.classList.add('hidden');
            testersList.innerHTML = testers.map(tester => `
                <div class="border border-slate-200 rounded-lg p-4 space-y-3">
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-medium text-slate-700">Tester ${testers.indexOf(tester) + 1}</span>
                        <button 
                            onclick="removeTester(${tester.id})" 
                            class="text-red-600 hover:text-red-700 text-sm font-medium"
                        >
                            Remove
                        </button>
                    </div>
                    <div>
                        <label class="block text-xs text-slate-600 mb-1">
                            Years of Experience: <span id="exp-${tester.id}">${tester.experience}</span>
                        </label>
                        <input 
                            type="range" 
                            min="0" 
                            max="5" 
                            value="${tester.experience}" 
                            oninput="updateTesterExperience(${tester.id}, this.value)"
                            class="w-full"
                        />
                    </div>
                    <div>
                        <label class="block text-xs text-slate-600 mb-1">Specialization</label>
                        <select 
                            onchange="updateTesterSpecialization(${tester.id}, this.value)"
                            class="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none"
                        >
                            <option value="Manual" ${tester.specialization === 'Manual' ? 'selected' : ''}>Manual</option>
                            <option value="Automation" ${tester.specialization === 'Automation' ? 'selected' : ''}>Automation</option>
                            <option value="Fresher" ${tester.specialization === 'Fresher' ? 'selected' : ''}>Fresher</option>
                        </select>
                    </div>
                </div>
            `).join('');
        }

            // Update Tester Experience
            window.updateTesterExperience = function(id, value) {
                const tester = testers.find(t => t.id === id);
                if (tester) {
                    tester.experience = parseInt(value);
                    document.getElementById(`exp-${id}`).textContent = value;
                }
            };

            // Update Tester Specialization
            window.updateTesterSpecialization = function(id, value) {
                const tester = testers.find(t => t.id === id);
                if (tester) {
                    tester.specialization = value;
                }
            };

            // Remove Tester
            window.removeTester = function(id) {
                testers = testers.filter(t => t.id !== id);
                renderTesters();
                checkGenerateButtonState();
            };

            // Check if Generate button should be enabled
            function checkGenerateButtonState() {
                const hasFile = fileInput.files.length > 0;
                const hasApiKey = apiKey.trim().length > 0;
                const hasTesters = testers.length > 0;
                
                generateBtn.disabled = !(hasFile && hasApiKey && hasTesters);
            }

            // Generate Test Plan
            generateBtn.addEventListener('click', async () => {
                if (!apiKey || fileInput.files.length === 0 || testers.length === 0) {
                    alert('Please fill in all required fields: API Key, Requirements Document, and at least one Tester');
                    return;
                }

                loadingOverlay.classList.remove('hidden');
                output.innerHTML = '';

                try {
                    // Extract text from file
                    const file = fileInput.files[0];
                    const requirementText = await extractTextFromFile(file);
                    const eta = etaInput.value.trim() || 'Not specified';

                    // Construct prompt
                    const resourcesText = testers.map((tester, idx) => 
                        `Tester ${idx + 1}: ${tester.experience} years of experience, Specialization: ${tester.specialization}`
                    ).join('\n');

                    const prompt = `You are an experienced QA Lead. Generate a comprehensive Test Plan based on the following requirements.

REQUIREMENTS DOCUMENT:
${requirementText}

EXECUTION TIMELINE:
${eta}

TEST TEAM:
${resourcesText}

Please generate a detailed Test Plan in Markdown format that includes:

1. **Test Plan Overview** - Brief introduction and purpose

2. **Test Scope and Objectives** - What will be tested and goals

3. **Test Strategy** - Overall approach and methodology

4. **Test Environment Requirements** - Infrastructure and setup needs

5. **Test Deliverables** - List of documents and artifacts

6. **Resource Allocation** - MUST be presented as a TABLE with columns:
   - Tester Name/ID
   - Years of Experience
   - Specialization
   - Assigned Tasks/Modules (keep concise, use bullet points if needed)
   - Estimated Effort
   - Responsibilities (brief summary)

7. **Task Allocation** - MUST be presented as a TABLE with columns:
   - Task ID
   - Task Description (keep brief, 1-2 sentences max)
   - Assigned Tester
   - Priority
   - Status
   - Dependencies (brief)
   - Estimated Duration

8. **Test Schedule/Timeline** - MUST be presented as a TABLE with columns:
   - Phase/Milestone
   - Start Date
   - End Date
   - Duration
   - Responsible Tester
   - Deliverables (brief list)

9. **Risk Assessment** - MUST be presented as a TABLE with columns:
   - Risk ID
   - Risk Description (concise)
   - Probability (High/Medium/Low)
   - Impact (High/Medium/Low)
   - Mitigation Strategy (brief)
   - Owner

10. **Entry and Exit Criteria** - Clear criteria for starting and completing testing

11. **Test Cases (high-level)** - Summary of test scenarios

IMPORTANT FORMATTING REQUIREMENTS:
- Use Markdown tables for ALL sections that involve structured data (Resource Allocation, Task Allocation, Schedule, Risk Assessment)
- Keep table cells CONCISE - maximum 2-3 sentences per cell. Use bullet points within cells if needed.
- Use proper Markdown table syntax with headers
- Ensure tables are well-formatted and readable with proper line breaks
- Each table row should be on a separate line in the markdown
- Add visual separators and clear section headers
- Use bullet points and numbered lists where appropriate
- Be specific about task assignments to each tester based on their experience and specialization
- DO NOT create extremely long table cells - keep content brief and to the point

MARKDOWN TABLE FORMAT EXAMPLE (use this exact syntax - each row on a new line):
| Column 1 | Column 2 | Column 3 |
|----------|---------|----------|
| Data 1   | Data 2  | Data 3   |
| Data 4   | Data 5  | Data 6   |

CRITICAL TABLE FORMATTING RULES:
1. You MUST use the pipe (|) and dash (-) syntax shown above for ALL tables
2. Each table row MUST be on a separate line
3. Keep cell content brief - if a cell needs more detail, use bullet points or keep it to 1-2 sentences
4. Do NOT use HTML tables, ASCII art, or any other format
5. Do NOT create tables with extremely long single-line cells
6. Ensure proper line breaks between table rows

Format the output as professional, well-structured Markdown with emphasis on tables for better readability.`;

                    // Call AI API based on selected provider
                    let markdownContent;
                    const provider = providers[apiProvider];
                    
                    if (apiProvider === 'openai') {
                        // OpenAI API call
                        const response = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: 'gpt-4',
                                messages: [
                                    {
                                        role: 'system',
                                        content: 'You are an expert QA Lead with extensive experience in creating comprehensive test plans. Always respond in Markdown format. CRITICAL: Use Markdown tables for Resource Allocation, Task Allocation, Test Schedule, and Risk Assessment sections. Format tables properly with clear headers and detailed information.'
                                    },
                                    {
                                        role: 'user',
                                        content: prompt
                                    }
                                ],
                                temperature: 0.7,
                                max_tokens: Math.min(tokenLimit, 16384) // OpenAI GPT-4 max is 16,384
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            let errorMessage = errorData.error?.message || 'Failed to generate test plan';
                            
                            if (errorMessage.includes('Incorrect API key') || errorMessage.includes('Invalid API key') || errorMessage.includes('API key')) {
                                errorMessage = `üîë API Key Error\n\n${errorMessage}\n\n‚ö†Ô∏è Make sure you're using a valid ${provider.name} API key.\n\nGet your API key from: ${provider.keyUrl}`;
                            }
                            
                            throw new Error(errorMessage);
                        }

                    const data = await response.json();
                    markdownContent = data.choices[0].message.content;
                    
                    // Check if response was truncated
                    if (data.choices[0].finish_reason === 'length') {
                        markdownContent += '\n\n---\n\n‚ö†Ô∏è **Note:** Response was truncated due to length limits. Some content may be incomplete.';
                    }
                    } else if (apiProvider === 'gemini') {
                        // Google Gemini API call - try multiple models with fallback
                        // Using latest models (2.5 series) as 1.5 models are deprecated
                        const geminiModels = [
                            { name: 'gemini-2.5-pro-latest', version: 'v1beta' },
                            { name: 'gemini-2.5-flash', version: 'v1beta' },
                            { name: 'gemini-pro', version: 'v1' },
                            { name: 'gemini-1.5-flash', version: 'v1beta' },
                            { name: 'gemini-pro', version: 'v1beta' }
                        ];

                        let lastError = null;
                        let response = null;
                        let data = null;

                        for (const model of geminiModels) {
                            try {
                                response = await fetch(`https://generativelanguage.googleapis.com/${model.version}/models/${model.name}:generateContent?key=${apiKey}`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        contents: [{
                                            parts: [{
                                                text: `You are an expert QA Lead with extensive experience in creating comprehensive test plans. Always respond in Markdown format. CRITICAL: Use Markdown tables for Resource Allocation, Task Allocation, Test Schedule, and Risk Assessment sections. Format tables properly with clear headers and detailed information.\n\n${prompt}`
                                            }]
                                        }],
                                        generationConfig: {
                                            temperature: 0.7,
                                            maxOutputTokens: Math.min(tokenLimit, 32000) // Gemini max is typically 32K
                                        }
                                    })
                                });

                                if (response.ok) {
                                    data = await response.json();
                                    break; // Success, exit loop
                                } else {
                                    const errorData = await response.json();
                                    lastError = errorData.error?.message || 'Failed to generate test plan';
                                    // Continue to next model if this one fails
                                }
                            } catch (err) {
                                lastError = err.message;
                                // Continue to next model
                            }
                        }

                        if (!response || !response.ok || !data) {
                            let errorMessage = lastError || 'Failed to generate test plan with any available Gemini model';
                            
                            if (errorMessage.includes('API key') || errorMessage.includes('invalid') || errorMessage.includes('permission') || errorMessage.includes('401') || errorMessage.includes('403')) {
                                errorMessage = `üîë API Key Error\n\n${errorMessage}\n\n‚ö†Ô∏è Make sure you're using a valid ${provider.name} API key.\n\nGet your API key from: ${provider.keyUrl}`;
                            } else {
                                errorMessage = `‚ö†Ô∏è Model Error\n\n${errorMessage}\n\nüí° Tried multiple Gemini models but none worked. Please check:\n- Your API key is valid and has proper permissions\n- Check available models at: https://ai.google.dev/models/gemini\n- Ensure Gemini API is enabled in your Google Cloud Console`;
                            }
                            
                            throw new Error(errorMessage);
                        }

                        markdownContent = data.candidates[0].content.parts[0].text;
                        
                        // Check if response was truncated
                        if (data.candidates[0].finishReason === 'MAX_TOKENS' || data.candidates[0].finishReason === 'OTHER') {
                            markdownContent += '\n\n---\n\n‚ö†Ô∏è **Note:** Response was truncated due to token limits. Some content may be incomplete. Consider regenerating with more specific requirements.';
                        }
                    }

                    // Post-process markdown to fix table formatting issues
                    // The API sometimes returns tables as extremely long single lines
                    // Try to detect and fix this pattern
                    
                    // Look for table patterns that span multiple pipe-separated sections
                    // If we find a very long line with many pipes, it might be a malformed table
                    const lines = markdownContent.split('\n');
                    let fixedContent = [];
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        // Check if this line looks like a table row but is extremely long
                        if (line.includes('|') && line.length > 1000) {
                            // This is likely a malformed table row
                            // Try to split it intelligently - look for patterns like "| Column |" repeated
                            // For now, just add a note and keep it
                            console.warn('Found extremely long table row at line', i, 'length:', line.length);
                            fixedContent.push(line);
                        } else {
                            fixedContent.push(line);
                        }
                    }
                    
                    markdownContent = fixedContent.join('\n');

                    // Render markdown with table support
                    let htmlContent;
                    try {
                        // Parse markdown
                        htmlContent = marked.parse(markdownContent);
                        
                        // Wrap all tables in a scrollable container
                        htmlContent = htmlContent.replace(/<table([^>]*)>([\s\S]*?)<\/table>/gi, (match, attrs, content) => {
                            return `<div class="table-wrapper"><table${attrs}>${content}</table></div>`;
                        });
                        
                        // Ensure tables are properly wrapped and visible
                        // Check if tables exist in the content
                        if (htmlContent.includes('<table')) {
                            // Tables are present, ensure they're styled
                            console.log('Tables detected in output');
                            
                            // Count tables
                            const tableCount = (htmlContent.match(/<table/g) || []).length;
                            console.log(`Found ${tableCount} table(s) in output`);
                        } else {
                            console.warn('No tables found in markdown output. Raw content preview:', markdownContent.substring(0, 1000));
                            
                            // Try to find table-like patterns in raw markdown
                            if (markdownContent.includes('|') && markdownContent.includes('---')) {
                                console.warn('Found pipe characters and dashes but tables not rendering. Markdown may be malformed.');
                                console.warn('Sample of markdown around table:', markdownContent.match(/\|.*\|.*\|/)?.[0]?.substring(0, 200));
                            }
                        }
                        
                        output.innerHTML = htmlContent;
                        downloadPdfBtn.classList.remove('hidden');
                    } catch (parseError) {
                        console.error('Markdown parsing error:', parseError);
                        // Fallback: display raw markdown with code formatting
                        output.innerHTML = `<pre class="bg-slate-100 p-4 rounded-lg overflow-auto">${markdownContent}</pre>`;
                        downloadPdfBtn.classList.remove('hidden');
                    }

                } catch (error) {
                    const errorText = error.message.replace(/\n/g, '<br>');
                    const provider = providers[apiProvider];
                    output.innerHTML = `
                        <div class="bg-red-50 border border-red-200 rounded-lg p-6">
                            <h3 class="text-red-800 font-semibold mb-3 text-lg">‚ùå Error</h3>
                            <p class="text-red-600 whitespace-pre-line">${errorText}</p>
                            <div class="mt-4 p-3 bg-red-100 rounded border border-red-300">
                                <p class="text-sm text-red-700 font-medium mb-1">üí° Quick Fix:</p>
                                <p class="text-sm text-red-600">1. Go to <a href="${provider.keyUrl}" target="_blank" class="underline">${provider.name} API Keys</a></p>
                                <p class="text-sm text-red-600">2. Create a new API key (it should start with "${provider.keyPrefix}")</p>
                                <p class="text-sm text-red-600">3. Copy and paste it in the API Key field above</p>
                            </div>
                        </div>
                    `;
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            });

            // Download PDF
            downloadPdfBtn.addEventListener('click', async () => {
                const element = output;
                const canvas = await html2canvas(element, {
                    scale: 2,
                    useCORS: true,
                    logging: false
                });

                const imgData = canvas.toDataURL('image/png');
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');

                const imgWidth = 210; // A4 width in mm
                const pageHeight = 297; // A4 height in mm
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                let heightLeft = imgHeight;
                let position = 0;

                pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;

                while (heightLeft >= 0) {
                    position = heightLeft - imgHeight;
                    pdf.addPage();
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }

                pdf.save('test-plan.pdf');
            });

            // Initial state check
            if (apiKey) {
                validateApiKey(apiKey);
            }
            checkGenerateButtonState();
            renderTesters();
        });
    </script>
</body>
</html>

